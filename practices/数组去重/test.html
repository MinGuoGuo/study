<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			// 这是用indexOf来搞,循环了一次indexOf又在新数组里面找了一遍，相当于做了两个循环；不好的干活
			// Array.prototype.getUnqiue = function () {
			// 	var newArr = [];
			// 	for (var i = 0; i < this.length; i++) {
			// 		if (newArr.indexOf(this[i]) == -1) {
			// 			newArr.push(this[i]);
			// 		}
			// 	}
			// 	return newArr;
			// }

			// 循环一次再到对象里面去找；
			/*Array.prototype.getUnqiue = function () {
				var newObj = {};
				var newArr = [];
				for (var i = 0; i < this.length; i++) {
					if (!newObj[this[i]]) {
						newObj[this[i]] = true;
						newArr.push(this[i]);
					}
				}
				return newArr;
			}*/
			// 这是利用indexOf返回的是当前元素的索引值来做的；
			/*Array.prototype.getUnqiue = function () {
				var newArr = [this[0]];
				for (var i = 0; i < this.length; i++) {
					if (this.indexOf(this[i]) == i) {
						newArr.push(this[i]);
					}
				}
				return newArr;
			}*/
			// 先把数组从打到小排序；然后在比较相邻两个元素；
			/*Array.prototype.getUnqiue = function () {
				this.sort();
				var newArr = [this[0]];
				for (var i = 1; i < this.length; i++) {
					if (this[i] != newArr[newArr.length - 1]) {
						newArr.push(this[i])
					}
				}
				return newArr;
			}*/

			// 结语第二种方法是最好的，效率最高的，第一第三四种方法都用到了用到了循环降低了效率；
		</script>
	</body>
</html>
